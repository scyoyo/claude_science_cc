"""
Exporter: Export meeting artifacts in various formats.

Supports:
- ZIP download: Bundle all code artifacts into a zip file (with subdirectories)
- GitHub push preparation: Generate file structure for GitHub
- Google Colab notebook: Convert code artifacts to .ipynb format
"""

import io
import json
import zipfile
from typing import List

from app.core.code_extractor import generate_requirements
from app.schemas.artifact import CodeArtifactResponse


def _build_directory_tree(filenames: List[str]) -> str:
    """Build a text-based directory tree from a list of file paths.

    Example output:
        src/
          models/
            pipeline.py
            utils.py
          main.py
        tests/
          test_pipeline.py
        requirements.txt
    """
    tree: dict = {}
    for name in sorted(filenames):
        parts = name.split("/")
        node = tree
        for part in parts:
            node = node.setdefault(part, {})

    lines: List[str] = []

    def _render(node: dict, indent: int = 0) -> None:
        for key in sorted(node.keys()):
            children = node[key]
            prefix = "  " * indent
            if children:
                lines.append(f"{prefix}{key}/")
                _render(children, indent + 1)
            else:
                lines.append(f"{prefix}{key}")

    _render(tree)
    return "\n".join(lines)


def export_as_zip(
    artifacts: List[dict],
    project_name: str = "virtual_lab_export",
) -> bytes:
    """Export artifacts as a ZIP file.

    Supports subdirectory structure via '/' in filenames.
    Automatically generates requirements.txt from Python imports.

    Args:
        artifacts: List of artifact dicts with 'filename', 'content', 'language' keys.
        project_name: Name of the root directory in the zip.

    Returns:
        Bytes of the ZIP file.
    """
    buffer = io.BytesIO()
    with zipfile.ZipFile(buffer, "w", zipfile.ZIP_DEFLATED) as zf:
        # Generate requirements.txt
        requirements = generate_requirements(artifacts)

        # Build file list for README
        filenames = [a["filename"] for a in artifacts]
        if requirements:
            filenames.append("requirements.txt")

        # Build README with directory tree
        readme = f"# {project_name}\n\nGenerated by Virtual Lab\n\n## Project Structure\n\n```\n"
        readme += _build_directory_tree(filenames)
        readme += "\n```\n"
        zf.writestr(f"{project_name}/README.md", readme)

        # Add each artifact (subdirectories are created automatically by zipfile)
        for a in artifacts:
            zf.writestr(f"{project_name}/{a['filename']}", a["content"])

        # Add requirements.txt if any packages detected
        if requirements:
            zf.writestr(f"{project_name}/requirements.txt", requirements)

    return buffer.getvalue()


def export_as_colab_notebook(
    artifacts: List[dict],
    project_name: str = "virtual_lab_export",
) -> dict:
    """Export artifacts as a Google Colab-compatible Jupyter notebook.

    Since notebooks don't support directories, file paths are annotated
    in markdown cells above each code cell.

    Args:
        artifacts: List of artifact dicts.
        project_name: Name for the notebook title.

    Returns:
        Dict representing the .ipynb JSON structure.
    """
    cells = []

    # Title cell
    cells.append({
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            f"# {project_name}\n",
            "\n",
            "Generated by Virtual Lab\n",
        ],
    })

    # One cell per artifact
    for a in artifacts:
        # Description markdown cell with filepath annotation
        desc = a.get("description", "")
        source_lines = [f"## {a['filename']}\n"]
        if "/" in a["filename"]:
            source_lines.append(f"\n> Target path: `{a['filename']}`\n")
        if desc:
            source_lines.append(f"\n{desc}\n")

        cells.append({
            "cell_type": "markdown",
            "metadata": {},
            "source": source_lines,
        })

        # Code cell
        cell_type = "code" if a["language"] in ("python", "py") else "code"
        code_source_lines = a["content"].split("\n")
        source_with_newlines = [line + "\n" for line in code_source_lines[:-1]]
        if code_source_lines:
            source_with_newlines.append(code_source_lines[-1])

        cells.append({
            "cell_type": cell_type,
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": source_with_newlines,
        })

    # Add requirements install cell if needed
    requirements = generate_requirements(artifacts)
    if requirements:
        pip_packages = " ".join(requirements.split("\n"))
        cells.insert(1, {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [f"!pip install {pip_packages}\n"],
        })

    notebook = {
        "nbformat": 4,
        "nbformat_minor": 0,
        "metadata": {
            "colab": {"name": f"{project_name}.ipynb"},
            "kernelspec": {
                "name": "python3",
                "display_name": "Python 3",
            },
            "language_info": {"name": "python"},
        },
        "cells": cells,
    }

    return notebook


def export_as_github_files(
    artifacts: List[dict],
    project_name: str = "virtual_lab_export",
) -> List[dict]:
    """Prepare artifacts as a list of files for GitHub push.

    Supports subdirectory paths in filenames.

    Args:
        artifacts: List of artifact dicts.
        project_name: Repository/project name.

    Returns:
        List of dicts with 'path' and 'content' keys ready for GitHub API.
    """
    files = []

    # Generate requirements.txt
    requirements = generate_requirements(artifacts)

    # Build file list for README
    filenames = [a["filename"] for a in artifacts]
    if requirements:
        filenames.append("requirements.txt")

    # README with directory tree
    readme = f"# {project_name}\n\nGenerated by Virtual Lab\n\n## Project Structure\n\n```\n"
    readme += _build_directory_tree(filenames)
    readme += "\n```\n"
    files.append({"path": "README.md", "content": readme})

    # Artifacts (path supports subdirectories)
    for a in artifacts:
        files.append({"path": a["filename"], "content": a["content"]})

    # Requirements
    if requirements:
        files.append({"path": "requirements.txt", "content": requirements})

    return files


def _escape_md_code(s: str) -> str:
    """Escape content for use inside markdown code blocks."""
    return s.replace("```", "` ` `")


def export_as_paper(
    meeting_title: str,
    meeting_description: str | None,
    messages: list[dict],
    artifacts: list[dict],
    summary: str | None = None,
) -> str:
    """Export meeting as an academic-style paper (markdown).

    Structure: title, abstract, discussion sections by round, code references, appendix (code).
    """
    title = meeting_title or "Meeting Output"
    lines = [
        f"# {title}",
        "",
        "*Generated from Virtual Lab meeting*",
        "",
        "---",
        "",
        "## Abstract",
        "",
        (meeting_description or summary or "This document summarizes the discussion and outputs from a virtual lab meeting.").strip(),
        "",
        "---",
        "",
        "## Discussion",
        "",
    ]

    current_round = None
    for msg in messages:
        role = msg.get("role", "assistant")
        agent = msg.get("agent_name", "Agent")
        content = (msg.get("content") or "").strip()
        rn = msg.get("round_number")
        if rn is not None and rn != current_round:
            current_round = rn
            lines.append(f"### Round {current_round}")
            lines.append("")
        if role == "user":
            lines.append(f"**User:** {_escape_md_code(content)}")
        else:
            lines.append(f"**{agent}:**")
            lines.append("")
            lines.append(content)
        lines.append("")
        lines.append("")

    if artifacts:
        lines.append("---")
        lines.append("")
        lines.append("## Generated Artifacts")
        lines.append("")
        for a in artifacts:
            fn = a.get("filename", "file")
            lines.append(f"- `{fn}`")
        lines.append("")
        lines.append("---")
        lines.append("")
        lines.append("## Appendix: Code")
        lines.append("")
        for a in artifacts:
            fn = a.get("filename", "file")
            lang = a.get("language", "text")
            content = a.get("content", "")
            lines.append(f"### {fn}")
            lines.append("")
            lines.append(f"```{lang}")
            lines.append(_escape_md_code(content))
            lines.append("```")
            lines.append("")

    return "\n".join(lines).strip()


def export_as_blog(
    meeting_title: str,
    meeting_description: str | None,
    messages: list[dict],
    artifacts: list[dict],
    summary: str | None = None,
) -> str:
    """Export meeting as a blog post (markdown).

    Narrative style: intro, discussion flow, code snippets inline.
    """
    title = meeting_title or "Meeting Notes"
    lines = [
        f"# {title}",
        "",
        (meeting_description or summary or "Notes from a virtual lab session.").strip(),
        "",
        "---",
        "",
    ]

    for msg in messages:
        role = msg.get("role", "assistant")
        agent = msg.get("agent_name", "Agent")
        content = (msg.get("content") or "").strip()
        if not content:
            continue
        if role == "user":
            lines.append(f"> **User:** {_escape_md_code(content)}")
        else:
            lines.append(f"### {agent}")
            lines.append("")
            lines.append(content)
        lines.append("")
        lines.append("")

    if artifacts:
        lines.append("---")
        lines.append("")
        lines.append("## Code from this session")
        lines.append("")
        for a in artifacts:
            fn = a.get("filename", "file")
            lang = a.get("language", "text")
            content = a.get("content", "")
            lines.append(f"**{fn}**")
            lines.append("")
            lines.append(f"```{lang}")
            lines.append(_escape_md_code(content))
            lines.append("```")
            lines.append("")

    return "\n".join(lines).strip()
